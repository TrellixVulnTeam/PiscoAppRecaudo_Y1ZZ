{"ast":null,"code":"/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nvar inheritAttributes = function inheritAttributes(el) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var attributeObject = {};\n  attributes.forEach(function (attr) {\n    if (el.hasAttribute(attr)) {\n      var value = el.getAttribute(attr);\n\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\nvar addEventListener = function addEventListener(el, eventName, callback, opts) {\n  if (typeof window !== 'undefined') {\n    var win = window;\n    var config = win && win.Ionic && win.Ionic.config;\n\n    if (config) {\n      var ael = config.get('_ael');\n\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      } else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.addEventListener(eventName, callback, opts);\n};\n\nvar removeEventListener = function removeEventListener(el, eventName, callback, opts) {\n  if (typeof window !== 'undefined') {\n    var win = window;\n    var config = win && win.Ionic && win.Ionic.config;\n\n    if (config) {\n      var rel = config.get('_rel');\n\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      } else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\n\n\nvar getElementRoot = function getElementRoot(el) {\n  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : el;\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\n\n\nvar raf = function raf(h) {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n\n  return setTimeout(h);\n};\n\nvar hasShadowDom = function hasShadowDom(el) {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\n\nvar findItemLabel = function findItemLabel(componentEl) {\n  var itemEl = componentEl.closest('ion-item');\n\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n\n  return null;\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\n\n\nvar getAriaLabel = function getAriaLabel(componentEl, inputId) {\n  var labelText; // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n\n  var labelledBy = componentEl.getAttribute('aria-labelledby'); // Grab the id off of the component in case they are using\n  // a custom label using the label element\n\n  var componentId = componentEl.id;\n  var labelId = labelledBy !== null && labelledBy.trim() !== '' ? labelledBy : inputId + '-lbl';\n  var label = labelledBy !== null && labelledBy.trim() !== '' ? document.querySelector(\"#\".concat(labelledBy)) : findItemLabel(componentEl);\n\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true'); // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  } else if (componentId.trim() !== '') {\n    label = document.querySelector(\"label[for=\".concat(componentId, \"]\"));\n\n    if (label) {\n      label.id = labelId = \"\".concat(componentId, \"-lbl\");\n      labelText = label.textContent;\n    }\n  }\n\n  return {\n    label: label,\n    labelId: labelId,\n    labelText: labelText\n  };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\n\n\nvar renderHiddenInput = function renderHiddenInput(always, container, name, value, disabled) {\n  if (always || hasShadowDom(container)) {\n    var input = container.querySelector('input.aux-input');\n\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\n\nvar clamp = function clamp(min, n, max) {\n  return Math.max(min, Math.min(n, max));\n};\n\nvar assert = function assert(actual, reason) {\n  if (!actual) {\n    var message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n\n    throw new Error(message);\n  }\n};\n\nvar now = function now(ev) {\n  return ev.timeStamp || Date.now();\n};\n\nvar pointerCoord = function pointerCoord(ev) {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    var changedTouches = ev.changedTouches;\n\n    if (changedTouches && changedTouches.length > 0) {\n      var touch = changedTouches[0];\n      return {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n    }\n\n    if (ev.pageX !== undefined) {\n      return {\n        x: ev.pageX,\n        y: ev.pageY\n      };\n    }\n  }\n\n  return {\n    x: 0,\n    y: 0\n  };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\n\n\nvar isEndSide = function isEndSide(side) {\n  var isRTL = document.dir === 'rtl';\n\n  switch (side) {\n    case 'start':\n      return isRTL;\n\n    case 'end':\n      return !isRTL;\n\n    default:\n      throw new Error(\"\\\"\".concat(side, \"\\\" is not a valid value for [side]. Use \\\"start\\\" or \\\"end\\\" instead.\"));\n  }\n};\n\nvar debounceEvent = function debounceEvent(event, wait) {\n  var original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\n\nvar debounce = function debounce(func) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var timer;\n  return function () {\n    clearTimeout(timer);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    timer = setTimeout.apply(void 0, [func, wait].concat(args));\n  };\n};\n\nexport { addEventListener as a, removeEventListener as b, getAriaLabel as c, renderHiddenInput as d, debounceEvent as e, findItemLabel as f, getElementRoot as g, clamp as h, inheritAttributes as i, hasShadowDom as j, assert as k, isEndSide as l, debounce as m, now as n, pointerCoord as p, raf as r };","map":{"version":3,"sources":["D:/Recaudooffline V.1.0.1/node_modules/@ionic/core/dist/esm/helpers-90f46169.js"],"names":["inheritAttributes","el","attributes","attributeObject","forEach","attr","hasAttribute","value","getAttribute","removeAttribute","addEventListener","eventName","callback","opts","window","win","config","Ionic","ael","get","_ael","removeEventListener","rel","_rel","getElementRoot","fallback","shadowRoot","raf","h","__zone_symbol__requestAnimationFrame","requestAnimationFrame","setTimeout","hasShadowDom","attachShadow","findItemLabel","componentEl","itemEl","closest","querySelector","getAriaLabel","inputId","labelText","labelledBy","componentId","id","labelId","trim","label","document","textContent","setAttribute","renderHiddenInput","always","container","name","disabled","input","ownerDocument","createElement","type","classList","add","appendChild","clamp","min","n","max","Math","assert","actual","reason","message","console","error","Error","now","ev","timeStamp","Date","pointerCoord","changedTouches","length","touch","x","clientX","y","clientY","pageX","undefined","pageY","isEndSide","side","isRTL","dir","debounceEvent","event","wait","original","_original","emit","debounce","bind","func","timer","clearTimeout","args","a","b","c","d","e","f","g","i","j","k","l","m","p","r"],"mappings":"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","sourcesContent":["/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      }\n      else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.addEventListener(eventName, callback, opts);\n};\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      }\n      else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nconst hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\nconst findItemLabel = (componentEl) => {\n  const itemEl = componentEl.closest('ion-item');\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n  return null;\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText;\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.querySelector(`#${labelledBy}`)\n    : findItemLabel(componentEl);\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n    // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  }\n  else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=${componentId}]`);\n    if (label) {\n      label.id = labelId = `${componentId}-lbl`;\n      labelText = label.textContent;\n    }\n  }\n  return { label, labelId, labelText };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n    throw new Error(message);\n  }\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\nconst pointerCoord = (ev) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return { x: touch.clientX, y: touch.clientY };\n    }\n    if (ev.pageX !== undefined) {\n      return { x: ev.pageX, y: ev.pageY };\n    }\n  }\n  return { x: 0, y: 0 };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\nconst isEndSide = (side) => {\n  const isRTL = document.dir === 'rtl';\n  switch (side) {\n    case 'start': return isRTL;\n    case 'end': return !isRTL;\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n\nexport { addEventListener as a, removeEventListener as b, getAriaLabel as c, renderHiddenInput as d, debounceEvent as e, findItemLabel as f, getElementRoot as g, clamp as h, inheritAttributes as i, hasShadowDom as j, assert as k, isEndSide as l, debounce as m, now as n, pointerCoord as p, raf as r };\n"]},"metadata":{},"sourceType":"module"}