{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { IonicNativePlugin, checkAvailability, cordovaPropertyGet, cordovaPropertySet, getPromise } from '@ionic-native/core';\n\nvar FileOriginal =\n/** @class */\nfunction (_super) {\n  __extends(FileOriginal, _super);\n\n  function FileOriginal() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cordovaFileError = {\n      1: 'NOT_FOUND_ERR',\n      2: 'SECURITY_ERR',\n      3: 'ABORT_ERR',\n      4: 'NOT_READABLE_ERR',\n      5: 'ENCODING_ERR',\n      6: 'NO_MODIFICATION_ALLOWED_ERR',\n      7: 'INVALID_STATE_ERR',\n      8: 'SYNTAX_ERR',\n      9: 'INVALID_MODIFICATION_ERR',\n      10: 'QUOTA_EXCEEDED_ERR',\n      11: 'TYPE_MISMATCH_ERR',\n      12: 'PATH_EXISTS_ERR',\n      13: 'WRONG_ENTRY_TYPE',\n      14: 'DIR_READ_ERR'\n    };\n    return _this;\n  }\n\n  FileOriginal.prototype.getFreeDiskSpace = function () {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return getPromise(function (resolve, reject) {\n          cordova.exec(resolve, reject, 'File', 'getFreeDiskSpace', []);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.checkDir = function (path, dir) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(dir)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        var fullPath = path + dir;\n        return _this.resolveDirectoryUrl(fullPath).then(function () {\n          return true;\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.createDir = function (path, dirName, replace) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(dirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        var options = {\n          create: true\n        };\n\n        if (!replace) {\n          options.exclusive = true;\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, options);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.removeDir = function (path, dirName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(dirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, {\n            create: false\n          });\n        }).then(function (de) {\n          return _this.remove(de);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.moveDir = function (path, dirName, newPath, newDirName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        newDirName = newDirName || dirName;\n\n        if (/^\\//.test(newDirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, {\n            create: false\n          });\n        }).then(function (srcde) {\n          return _this.resolveDirectoryUrl(newPath).then(function (destenation) {\n            return _this.move(srcde, destenation, newDirName);\n          });\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.copyDir = function (path, dirName, newPath, newDirName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(newDirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, {\n            create: false\n          });\n        }).then(function (srcde) {\n          return _this.resolveDirectoryUrl(newPath).then(function (deste) {\n            return _this.copy(srcde, deste, newDirName);\n          });\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.listDir = function (path, dirName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(dirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, {\n            create: false,\n            exclusive: false\n          });\n        }).then(function (de) {\n          var reader = de.createReader();\n          return _this.readEntries(reader);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.removeRecursively = function (path, dirName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(dirName)) {\n          var err = new FileError(5);\n          err.message = 'directory cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getDirectory(fse, dirName, {\n            create: false\n          });\n        }).then(function (de) {\n          return _this.rimraf(de);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.checkFile = function (path, file) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(file)) {\n          var err = new FileError(5);\n          err.message = 'file cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveLocalFilesystemUrl(path + file).then(function (fse) {\n          if (fse.isFile) {\n            return true;\n          } else {\n            var err = new FileError(13);\n            err.message = 'input is not a file';\n            return Promise.reject(err);\n          }\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.createFile = function (path, fileName, replace) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(fileName)) {\n          var err = new FileError(5);\n          err.message = 'file-name cannot start with /';\n          return Promise.reject(err);\n        }\n\n        var options = {\n          create: true\n        };\n\n        if (!replace) {\n          options.exclusive = true;\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getFile(fse, fileName, options);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.removeFile = function (path, fileName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(fileName)) {\n          var err = new FileError(5);\n          err.message = 'file-name cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getFile(fse, fileName, {\n            create: false\n          });\n        }).then(function (fe) {\n          return _this.remove(fe);\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.writeFile = function (path, fileName, text, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        if (/^\\//.test(fileName)) {\n          var err = new FileError(5);\n          err.message = 'file-name cannot start with /';\n          return Promise.reject(err);\n        }\n\n        var getFileOpts = {\n          create: !options.append,\n          exclusive: !options.replace\n        };\n        return _this.resolveDirectoryUrl(path).then(function (directoryEntry) {\n          return _this.getFile(directoryEntry, fileName, getFileOpts);\n        }).then(function (fileEntry) {\n          return _this.writeFileEntry(fileEntry, text, options);\n        });\n      }\n    }();\n  };\n  /**\n   * Write content to FileEntry.\n   * @hidden\n   * Write to an existing file.\n   * @param {FileEntry} fe file entry object\n   * @param {string | Blob | ArrayBuffer} text text content or blob to write\n   * @param {IWriteOptions} options replace file if set to true. See WriteOptions for more information.\n   * @returns {Promise<FileEntry>}  Returns a Promise that resolves to updated file entry or rejects with an error.\n   */\n\n\n  FileOriginal.prototype.writeFileEntry = function (fe, text, options) {\n    var _this = this;\n\n    return this.createWriter(fe).then(function (writer) {\n      if (options.append) {\n        writer.seek(writer.length);\n      }\n\n      if (options.truncate) {\n        writer.truncate(options.truncate);\n      }\n\n      return _this.write(writer, text);\n    }).then(function () {\n      return fe;\n    });\n  };\n\n  FileOriginal.prototype.writeExistingFile = function (path, fileName, text) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.writeFile(path, fileName, text, {\n          replace: true\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.readAsText = function (path, file) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.readFile(path, file, 'Text');\n      }\n    }();\n  };\n\n  FileOriginal.prototype.readAsDataURL = function (path, file) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.readFile(path, file, 'DataURL');\n      }\n    }();\n  };\n\n  FileOriginal.prototype.readAsBinaryString = function (path, file) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.readFile(path, file, 'BinaryString');\n      }\n    }();\n  };\n\n  FileOriginal.prototype.readAsArrayBuffer = function (path, file) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.readFile(path, file, 'ArrayBuffer');\n      }\n    }();\n  };\n\n  FileOriginal.prototype.moveFile = function (path, fileName, newPath, newFileName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        newFileName = newFileName || fileName;\n\n        if (/^\\//.test(newFileName)) {\n          var err = new FileError(5);\n          err.message = 'file name cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getFile(fse, fileName, {\n            create: false\n          });\n        }).then(function (srcfe) {\n          return _this.resolveDirectoryUrl(newPath).then(function (deste) {\n            return _this.move(srcfe, deste, newFileName);\n          });\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.copyFile = function (path, fileName, newPath, newFileName) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        newFileName = newFileName || fileName;\n\n        if (/^\\//.test(newFileName)) {\n          var err = new FileError(5);\n          err.message = 'file name cannot start with /';\n          return Promise.reject(err);\n        }\n\n        return _this.resolveDirectoryUrl(path).then(function (fse) {\n          return _this.getFile(fse, fileName, {\n            create: false\n          });\n        }).then(function (srcfe) {\n          return _this.resolveDirectoryUrl(newPath).then(function (deste) {\n            return _this.copy(srcfe, deste, newFileName);\n          });\n        });\n      }\n    }();\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.fillErrorMessage = function (err) {\n    try {\n      err.message = this.cordovaFileError[err.code];\n    } catch (e) {}\n  };\n\n  FileOriginal.prototype.resolveLocalFilesystemUrl = function (fileUrl) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return getPromise(function (resolve, reject) {\n          try {\n            window.resolveLocalFileSystemURL(fileUrl, function (entry) {\n              resolve(entry);\n            }, function (err) {\n              _this.fillErrorMessage(err);\n\n              reject(err);\n            });\n          } catch (xc) {\n            _this.fillErrorMessage(xc);\n\n            reject(xc);\n          }\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.resolveDirectoryUrl = function (directoryUrl) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return _this.resolveLocalFilesystemUrl(directoryUrl).then(function (de) {\n          if (de.isDirectory) {\n            return de;\n          } else {\n            var err = new FileError(13);\n            err.message = 'input is not a directory';\n            return Promise.reject(err);\n          }\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.getDirectory = function (directoryEntry, directoryName, flags) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return new Promise(function (resolve, reject) {\n          try {\n            directoryEntry.getDirectory(directoryName, flags, function (de) {\n              resolve(de);\n            }, function (err) {\n              _this.fillErrorMessage(err);\n\n              reject(err);\n            });\n          } catch (xc) {\n            _this.fillErrorMessage(xc);\n\n            reject(xc);\n          }\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.getFile = function (directoryEntry, fileName, flags) {\n    var _this = this;\n\n    return function () {\n      if (checkAvailability(_this) === true) {\n        return new Promise(function (resolve, reject) {\n          try {\n            directoryEntry.getFile(fileName, flags, resolve, function (err) {\n              _this.fillErrorMessage(err);\n\n              reject(err);\n            });\n          } catch (xc) {\n            _this.fillErrorMessage(xc);\n\n            reject(xc);\n          }\n        });\n      }\n    }();\n  };\n\n  FileOriginal.prototype.readFile = function (path, file, readAs) {\n    var _this = this;\n\n    if (/^\\//.test(file)) {\n      var err = new FileError(5);\n      err.message = 'file-name cannot start with /';\n      return Promise.reject(err);\n    }\n\n    return this.resolveDirectoryUrl(path).then(function (directoryEntry) {\n      return _this.getFile(directoryEntry, file, {\n        create: false\n      });\n    }).then(function (fileEntry) {\n      var reader = new FileReader();\n      return getPromise(function (resolve, reject) {\n        reader.onloadend = function () {\n          if (reader.result !== undefined || reader.result !== null) {\n            resolve(reader.result);\n          } else if (reader.error !== undefined || reader.error !== null) {\n            reject(reader.error);\n          } else {\n            reject({\n              code: null,\n              message: 'READER_ONLOADEND_ERR'\n            });\n          }\n        };\n\n        fileEntry.file(function (file) {\n          reader[\"readAs\" + readAs].call(reader, file);\n        }, function (error) {\n          reject(error);\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.remove = function (fe) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      fe.remove(function () {\n        resolve({\n          success: true,\n          fileRemoved: fe\n        });\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.move = function (srce, destdir, newName) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      srce.moveTo(destdir, newName, function (deste) {\n        resolve(deste);\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.copy = function (srce, destdir, newName) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      srce.copyTo(destdir, newName, function (deste) {\n        resolve(deste);\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.readEntries = function (dr) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      dr.readEntries(function (entries) {\n        resolve(entries);\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.rimraf = function (de) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      de.removeRecursively(function () {\n        resolve({\n          success: true,\n          fileRemoved: de\n        });\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.createWriter = function (fe) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      fe.createWriter(function (writer) {\n        resolve(writer);\n      }, function (err) {\n        _this.fillErrorMessage(err);\n\n        reject(err);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.write = function (writer, gu) {\n    if (gu instanceof Blob) {\n      return this.writeFileInChunks(writer, gu);\n    }\n\n    return new Promise(function (resolve, reject) {\n      writer.onwriteend = function (evt) {\n        if (writer.error) {\n          reject(writer.error);\n        } else {\n          resolve(evt);\n        }\n      };\n\n      writer.write(gu);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  FileOriginal.prototype.writeFileInChunks = function (writer, file) {\n    var BLOCK_SIZE = 1024 * 1024;\n    var writtenSize = 0;\n\n    function writeNextChunk() {\n      var size = Math.min(BLOCK_SIZE, file.size - writtenSize);\n      var chunk = file.slice(writtenSize, writtenSize + size);\n      writtenSize += size;\n      writer.write(chunk);\n    }\n\n    return getPromise(function (resolve, reject) {\n      writer.onerror = reject;\n\n      writer.onwrite = function () {\n        if (writtenSize < file.size) {\n          writeNextChunk();\n        } else {\n          resolve();\n        }\n      };\n\n      writeNextChunk();\n    });\n  };\n\n  Object.defineProperty(FileOriginal.prototype, \"applicationDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"applicationDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"applicationDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"applicationStorageDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"applicationStorageDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"applicationStorageDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"dataDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"dataDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"dataDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"cacheDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"cacheDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"cacheDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"externalApplicationStorageDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"externalApplicationStorageDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"externalApplicationStorageDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"externalDataDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"externalDataDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"externalDataDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"externalCacheDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"externalCacheDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"externalCacheDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"externalRootDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"externalRootDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"externalRootDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"tempDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"tempDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"tempDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"syncedDataDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"syncedDataDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"syncedDataDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"documentsDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"documentsDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"documentsDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileOriginal.prototype, \"sharedDirectory\", {\n    get: function get() {\n      return cordovaPropertyGet(this, \"sharedDirectory\");\n    },\n    set: function set(value) {\n      cordovaPropertySet(this, \"sharedDirectory\", value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FileOriginal.pluginName = \"File\";\n  FileOriginal.plugin = \"cordova-plugin-file\";\n  FileOriginal.pluginRef = \"cordova.file\";\n  FileOriginal.repo = \"https://github.com/apache/cordova-plugin-file\";\n  FileOriginal.platforms = [\"Android\", \"Browser\", \"iOS\", \"macOS\", \"Windows\"];\n  return FileOriginal;\n}(IonicNativePlugin);\n\nvar File = new FileOriginal();\nexport { File };","map":{"version":3,"sources":["../../../../src/@ionic-native/plugins/file/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { CordovaCheck, CordovaProperty, IonicNativePlugin, Plugin, getPromise } from '@ionic-native/core';\n\nexport interface IFile extends Blob {\n  /**\n   * Name of the file, without path information\n   */\n  name: string;\n  /**\n   * Last modified date\n   */\n  lastModified: number;\n  /**\n   * Last modified date\n   */\n  lastModifiedDate: number;\n  /**\n   * Size in bytes\n   */\n  size: number;\n  /**\n   * File mime type\n   */\n  type: string;\n  localURL: string;\n  start: number;\n  end: number;\n\n  /**\n   * Returns a \"slice\" of the file. Since Cordova Files don't contain the actual\n   * content, this really returns a File with adjusted start and end.\n   * Slices of slices are supported.\n   * @param start {Number} The index at which to start the slice (inclusive).\n   * @param end {Number} The index at which to end the slice (exclusive).\n   */\n  slice(start: number, end: number): Blob;\n}\n\nexport interface LocalFileSystem {\n  /**\n   * Used for storage with no guarantee of persistence.\n   */\n  TEMPORARY: number;\n\n  /**\n   * Used for storage that should not be removed by the user agent without application or user permission.\n   */\n  PERSISTENT: number;\n\n  /**\n   * Requests a filesystem in which to store application data.\n   * @param type Whether the filesystem requested should be persistent, as defined above. Use one of TEMPORARY or\n   *   PERSISTENT.\n   * @param size This is an indicator of how much storage space, in bytes, the application expects to need.\n   * @param successCallback The callback that is called when the user agent provides a filesystem.\n   * @param errorCallback A callback that is called when errors happen, or when the request to obtain the filesystem is\n   *   denied.\n   */\n  requestFileSystem(\n    type: number,\n    size: number,\n    successCallback: FileSystemCallback,\n    errorCallback?: ErrorCallback\n  ): void;\n\n  /**\n   * Allows the user to look up the Entry for a file or directory referred to by a local URL.\n   * @param url A URL referring to a local file in a filesystem accessable via this API.\n   * @param successCallback A callback that is called to report the FileEntry to which the supplied URL refers.\n   * @param errorCallback A callback that is called when errors happen, or when the request to obtain the Entry is\n   *   denied.\n   */\n  resolveLocalFileSystemURL(url: string, successCallback: FileEntryCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * see requestFileSystem.\n   */\n  webkitRequestFileSystem(\n    type: number,\n    size: number,\n    successCallback: FileSystemCallback,\n    errorCallback?: ErrorCallback\n  ): void;\n}\n\nexport interface Metadata {\n  /**\n   * This is the time at which the file or directory was last modified.\n   * @readonly\n   */\n  modificationTime: Date;\n\n  /**\n   * The size of the file, in bytes. This must return 0 for directories.\n   * @readonly\n   */\n  size: number;\n}\n\nexport interface Flags {\n  /**\n   * Used to indicate that the user wants to create a file or directory if it was not previously there.\n   */\n  create?: boolean;\n\n  /**\n   * By itself, exclusive must have no effect. Used with create, it must cause getFile and getDirectory to fail if the\n   * target path already exists.\n   */\n  exclusive?: boolean;\n}\n\n/**\n * This export interface represents a file system.\n */\nexport interface FileSystem {\n  /**\n   * This is the name of the file system. The specifics of naming filesystems is unspecified, but a name must be unique\n   * across the list of exposed file systems.\n   * @readonly\n   */\n  name: string;\n\n  /**\n   * The root directory of the file system.\n   * @readonly\n   */\n  root: DirectoryEntry;\n\n  toJSON(): string;\n\n  encodeURIPath(path: string): string;\n}\n\nexport interface Entry {\n  /**\n   * Entry is a file.\n   */\n  isFile: boolean;\n\n  /**\n   * Entry is a directory.\n   */\n  isDirectory: boolean;\n\n  /**\n   * Look up metadata about this entry.\n   * @param successCallback A callback that is called with the time of the last modification.\n   * @param errorCallback ErrorCallback A callback that is called when errors happen.\n   */\n  getMetadata(successCallback: MetadataCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * Set the metadata of the entry.\n   * @param successCallback {Function} is called with a Metadata object\n   * @param errorCallback {Function} is called with a FileError\n   * @param metadataObject {Metadata} keys and values to set\n   */\n  setMetadata(successCallback: MetadataCallback, errorCallback: ErrorCallback, metadataObject: Metadata): void;\n\n  /**\n   * The name of the entry, excluding the path leading to it.\n   */\n  name: string;\n  /**\n   * The full absolute path from the root to the entry.\n   */\n  fullPath: string;\n  /**\n   * The file system on which the entry resides.\n   */\n  filesystem: FileSystem;\n  /**\n   * an alternate URL which can be used by native webview controls, for example media players.\n   */\n  nativeURL: string;\n\n  /**\n   * Look up metadata about this entry.\n   * @param successCallback A callback that is called with the time of the last modification.\n   * @param errorCallback ErrorCallback A callback that is called when errors happen.\n   */\n  getMetadata(successCallback: MetadataCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * Set the metadata of the entry.\n   * @param successCallback {Function} is called with a Metadata object\n   * @param errorCallback {Function} is called with a FileError\n   * @param metadataObject {Metadata} keys and values to set\n   */\n  setMetadata(successCallback: MetadataCallback, errorCallback: ErrorCallback, metadataObject: Metadata): void;\n\n  /**\n   * Move an entry to a different location on the file system. It is an error to try to:\n   *\n   * <ui>\n   * <li>move a directory inside itself or to any child at any depth;</li>\n   * <li>move an entry into its parent if a name different from its current one isn't provided;</li>\n   * <li>move a file to a path occupied by a directory;</li>\n   * <li>move a directory to a path occupied by a file;</li>\n   * <li>move any element to a path occupied by a directory which is not empty.</li>\n   * <ul>\n   *\n   * A move of a file on top of an existing file must attempt to delete and replace that file.\n   * A move of a directory on top of an existing empty directory must attempt to delete and replace that directory.\n   */\n  moveTo(\n    parent: DirectoryEntry,\n    newName?: string,\n    successCallback?: EntryCallback,\n    errorCallback?: ErrorCallback\n  ): void;\n\n  /**\n   * Copy an entry to a different location on the file system. It is an error to try to:\n   *\n   * <ul>\n   * <li> copy a directory inside itself or to any child at any depth;</li>\n   * <li> copy an entry into its parent if a name different from its current one isn't provided;</li>\n   * <li> copy a file to a path occupied by a directory;</li>\n   * <li> copy a directory to a path occupied by a file;</li>\n   * <li> copy any element to a path occupied by a directory which is not empty.</li>\n   * <li> A copy of a file on top of an existing file must attempt to delete and replace that file.</li>\n   * <li> A copy of a directory on top of an existing empty directory must attempt to delete and replace that\n   * directory.</li>\n   * </ul>\n   *\n   * Directory copies are always recursive--that is, they copy all contents of the directory.\n   */\n  copyTo(\n    parent: DirectoryEntry,\n    newName?: string,\n    successCallback?: EntryCallback,\n    errorCallback?: ErrorCallback\n  ): void;\n\n  /**\n   * Returns a URL that can be used to identify this entry. Unlike the URN defined in [FILE-API-ED], it has no specific\n   * expiration; as it describes a location on disk, it should be valid at least as long as that location exists.\n   */\n  toURL(): string;\n\n  /**\n   * Return a URL that can be passed across the bridge to identify this entry.\n   * @return string URL that can be passed across the bridge to identify this entry\n   */\n  toInternalURL(): string;\n\n  /**\n   * Deletes a file or directory. It is an error to attempt to delete a directory that is not empty. It is an error to\n   * attempt to delete the root directory of a filesystem.\n   * @param successCallback A callback that is called on success.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  remove(successCallback: VoidCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * Look up the parent DirectoryEntry containing this Entry. If this Entry is the root of its filesystem, its parent\n   * is itself.\n   * @param successCallback A callback that is called to return the parent Entry.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  getParent(successCallback: DirectoryEntryCallback, errorCallback?: ErrorCallback): void;\n}\n\n/**\n * This export interface represents a directory on a file system.\n */\nexport interface DirectoryEntry extends Entry {\n  /**\n   * Creates a new DirectoryReader to read Entries from this Directory.\n   */\n  createReader(): DirectoryReader;\n\n  /**\n   * Creates or looks up a file.\n   * @param path Either an absolute path or a relative path from this DirectoryEntry to the file to be looked up or\n   *   created. It is an error to attempt to create a file whose immediate parent does not yet exist.\n   * @param options\n   *     <ul>\n   *     <li>If create and exclusive are both true, and the path already exists, getFile must fail.</li>\n   *     <li>If create is true, the path doesn't exist, and no other error occurs, getFile must create it as a\n   *   zero-length file and return a corresponding FileEntry.</li>\n   *     <li>If create is not true and the path doesn't exist, getFile must fail.</li>\n   *     <li>If create is not true and the path exists, but is a directory, getFile must fail.</li>\n   *     <li>Otherwise, if no other error occurs, getFile must return a FileEntry corresponding to path.</li>\n   *     </ul>\n   * @param successCallback A callback that is called to return the File selected or created.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  getFile(path: string, options?: Flags, successCallback?: FileEntryCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * Creates or looks up a directory.\n   * @param path Either an absolute path or a relative path from this DirectoryEntry to the directory to be looked up\n   *   or created. It is an error to attempt to create a directory whose immediate parent does not yet exist.\n   * @param options\n   *     <ul>\n   *     <li>If create and exclusive are both true and the path already exists, getDirectory must fail.</li>\n   *     <li>If create is true, the path doesn't exist, and no other error occurs, getDirectory must create and return\n   *   a corresponding DirectoryEntry.</li>\n   *     <li>If create is not true and the path doesn't exist, getDirectory must fail.</li>\n   *     <li>If create is not true and the path exists, but is a file, getDirectory must fail.</li>\n   *     <li>Otherwise, if no other error occurs, getDirectory must return a DirectoryEntry corresponding to path.</li>\n   *     </ul>\n   * @param successCallback   A callback that is called to return the DirectoryEntry selected or created.\n   * @param errorCallback A callback that is called when errors happen.\n   *\n   */\n  getDirectory(\n    path: string,\n    options?: Flags,\n    successCallback?: DirectoryEntryCallback,\n    errorCallback?: ErrorCallback\n  ): void;\n\n  /**\n   * Deletes a directory and all of its contents, if any. In the event of an error [e.g. trying to delete a directory\n   * that contains a file that cannot be removed], some of the contents of the directory may be deleted. It is an error\n   * to attempt to delete the root directory of a filesystem.\n   * @param successCallback A callback that is called on success.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  removeRecursively(successCallback: VoidCallback, errorCallback?: ErrorCallback): void;\n}\n\n/**\n * This export interface lets a user list files and directories in a directory. If there are no additions to or\n * deletions from a directory between the first and last call to readEntries, and no errors occur, then:\n * <ul>\n * <li> A series of calls to readEntries must return each entry in the directory exactly once.</li>\n * <li> Once all entries have been returned, the next call to readEntries must produce an empty array.</li>\n * <li> If not all entries have been returned, the array produced by readEntries must not be empty.</li>\n * <li> The entries produced by readEntries must not include the directory itself [\".\"] or its parent [\"..\"].</li>\n * </ul>\n */\nexport interface DirectoryReader {\n  localURL: string;\n  hasReadEntries: boolean;\n\n  /**\n   * Read the next block of entries from this directory.\n   * @param successCallback Called once per successful call to readEntries to deliver the next previously-unreported\n   *   set of Entries in the associated Directory. If all Entries have already been returned from previous invocations\n   *   of readEntries, successCallback must be called with a zero-length array as an argument.\n   * @param errorCallback A callback indicating that there was an error reading from the Directory.\n   */\n  readEntries(successCallback: EntriesCallback, errorCallback?: ErrorCallback): void;\n}\n\n/**\n * This export interface represents a file on a file system.\n */\nexport interface FileEntry extends Entry {\n  /**\n   * Creates a new FileWriter associated with the file that this FileEntry represents.\n   * @param successCallback A callback that is called with the new FileWriter.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  createWriter(successCallback: FileWriterCallback, errorCallback?: ErrorCallback): void;\n\n  /**\n   * Returns a File that represents the current state of the file that this FileEntry represents.\n   * @param successCallback A callback that is called with the File.\n   * @param errorCallback A callback that is called when errors happen.\n   */\n  file(successCallback: FileCallback, errorCallback?: ErrorCallback): void;\n}\n\n/**\n * When requestFileSystem() succeeds, the following callback is made.\n */\nexport type FileSystemCallback = (filesystem: FileSystem) => void;\n\n/**\n * This export interface is the callback used to look up Entry objects.\n */\nexport type EntryCallback = (entry: Entry) => void;\n\n/**\n * This export interface is the callback used to look up FileEntry objects.\n */\nexport type FileEntryCallback = (entry: FileEntry) => void;\n\n/**\n * This export interface is the callback used to look up DirectoryEntry objects.\n */\nexport type DirectoryEntryCallback = (entry: DirectoryEntry) => void;\n\n/**\n * When readEntries() succeeds, the following callback is made.\n */\nexport type EntriesCallback = (entries: Entry[]) => void;\n\n/**\n * This export interface is the callback used to look up file and directory metadata.\n */\nexport type MetadataCallback = (metadata: Metadata) => void;\n\n/**\n * This export interface is the callback used to create a FileWriter.\n */\nexport type FileWriterCallback = (fileWriter: FileWriter) => void;\n\n/**\n * This export interface is the callback used to obtain a File.\n */\nexport type FileCallback = (file: IFile) => void;\n\n/**\n * This export interface is the generic callback used to indicate success of an asynchronous method.\n */\nexport type VoidCallback = () => void;\n\n/**\n * When an error occurs, the following callback is made.\n */\nexport type ErrorCallback = (err: FileError) => void;\n\nexport interface RemoveResult {\n  success: boolean;\n  fileRemoved: Entry;\n}\n\n/** @hidden */\nexport declare class FileSaver extends EventTarget {\n  /**\n   * When the FileSaver constructor is called, the user agent must return a new FileSaver object with readyState set to\n   * INIT. This constructor must be visible when the script's global object is either a Window object or an object\n   * implementing the WorkerUtils interface.\n   */\n  constructor(data: Blob);\n\n  /**\n   * When the abort method is called, user agents must run the steps below:\n   * <ol>\n   * <li> If readyState == DONE or readyState == INIT, terminate this overall series of steps without doing anything\n   * else. </li>\n   * <li> Set readyState to DONE. </li>\n   * <li> If there are any tasks from the object's FileSaver task source in one of the task queues, then remove those\n   * tasks. </li>\n   * <li> Terminate the write algorithm being processed. </li>\n   * <li> Set the error attribute to a DOMError object of type \"AbortError\". </li>\n   * <li> Fire a progress event called abort </li>\n   * <li> Fire a progress event called write end </li>\n   * <li> Terminate this algorithm. </li>\n   * </ol>\n   */\n  abort(): void;\n\n  /**\n   * The blob is being written.\n   * @readonly\n   */\n  INIT: number;\n  /**\n   * The object has been constructed, but there is no pending write.\n   * @readonly\n   */\n  WRITING: number;\n  /**\n   * The entire Blob has been written to the file, an error occurred during the write, or the write was aborted using\n   * abort(). The FileSaver is no longer writing the blob.\n   * @readonly\n   */\n  DONE: number;\n  /**\n   * The FileSaver object can be in one of 3 states. The readyState attribute, on getting, must return the current\n   * state, which must be one of the following values:\n   * <ul>\n   * <li>INIT</li>\n   * <li>WRITING</li>\n   * <li>DONE</li>\n   * <ul>\n   * @readonly\n   */\n  readyState: number;\n  /**\n   * The last error that occurred on the FileSaver.\n   * @readonly\n   */\n  error: Error;\n  /**\n   * Handler for write start events\n   */\n  onwritestart: (event: ProgressEvent) => void;\n  /**\n   * Handler for progress events.\n   */\n  onprogress: (event: ProgressEvent) => void;\n  /**\n   * Handler for write events.\n   */\n  onwrite: (event: ProgressEvent) => void;\n  /**\n   * Handler for abort events.\n   */\n  onabort: (event: ProgressEvent) => void;\n  /**\n   * Handler for error events.\n   */\n  onerror: (event: ProgressEvent) => void;\n  /**\n   * Handler for write end events.\n   */\n  onwriteend: (event: ProgressEvent) => void;\n\n  /**\n   * When the FileSaver constructor is called, the user agent must return a new FileSaver object with readyState set to\n   * INIT. This constructor must be visible when the script's global object is either a Window object or an object\n   * implementing the WorkerUtils interface.\n   */\n  constructor(data: Blob);\n\n  /**\n   * When the abort method is called, user agents must run the steps below:\n   * <ol>\n   * <li> If readyState == DONE or readyState == INIT, terminate this overall series of steps without doing anything\n   * else. </li>\n   * <li> Set readyState to DONE. </li>\n   * <li> If there are any tasks from the object's FileSaver task source in one of the task queues, then remove those\n   * tasks. </li>\n   * <li> Terminate the write algorithm being processed. </li>\n   * <li> Set the error attribute to a DOMError object of type \"AbortError\". </li>\n   * <li> Fire a progress event called abort </li>\n   * <li> Fire a progress event called writeend </li>\n   * <li> Terminate this algorithm. </li>\n   * </ol>\n   */\n  abort(): void;\n}\n\n/**\n * @hidden\n * This interface expands on the FileSaver interface to allow for multiple write actions, rather than just saving a\n *   single Blob.\n */\nexport declare class FileWriter extends FileSaver {\n  /**\n   * The byte offset at which the next write to the file will occur. This must be no greater than length.\n   * A newly-created FileWriter must have position set to 0.\n   */\n  position: number;\n\n  /**\n   * The length of the file. If the user does not have read access to the file, this must be the highest byte offset at\n   * which the user has written.\n   */\n  length: number;\n\n  /**\n   * Write the supplied data to the file at position.\n   * @param data The blob to write.\n   */\n  write(data: ArrayBuffer | Blob | string): void;\n\n  /**\n   * Seek sets the file position at which the next write will occur.\n   * @param offset If nonnegative, an absolute byte offset into the file. If negative, an offset back from the end of\n   *   the file.\n   */\n  seek(offset: number): void;\n\n  /**\n   * Changes the length of the file to that specified. If shortening the file, data beyond the new length must be\n   * discarded. If extending the file, the existing data must be zero-padded up to the new length.\n   * @param size The size to which the length of the file is to be adjusted, measured in bytes.\n   */\n  truncate(size: number): void;\n}\n\nexport interface IWriteOptions {\n  replace?: boolean;\n  append?: boolean;\n  truncate?: number; // if present, number of bytes to truncate file to before writing\n}\n\n/** @hidden */\nexport declare class FileError {\n  static NOT_FOUND_ERR: number;\n  static SECURITY_ERR: number;\n  static ABORT_ERR: number;\n  static NOT_READABLE_ERR: number;\n  static ENCODING_ERR: number;\n  static NO_MODIFICATION_ALLOWED_ERR: number;\n  static INVALID_STATE_ERR: number;\n  static SYNTAX_ERR: number;\n  static INVALID_MODIFICATION_ERR: number;\n  static QUOTA_EXCEEDED_ERR: number;\n  static TYPE_MISMATCH_ERR: number;\n  static PATH_EXISTS_ERR: number;\n  /** Error code */\n  code: number;\n  message: string;\n\n  constructor(code: number);\n}\n\n/** @hidden */\nexport declare class FileReader {\n  static EMPTY: number;\n  static LOADING: number;\n  static DONE: number;\n  static READ_CHUNK_SIZE: number;\n\n  readyState: number; // see constants in var declaration below\n  error: Error;\n  result: string | ArrayBuffer; // type depends on readAsXXX() call type\n\n  onloadstart: (evt: ProgressEvent) => void;\n  onprogress: (evt: ProgressEvent) => void;\n  onload: (evt: ProgressEvent) => void;\n  onerror: (evt: ProgressEvent) => void;\n  onloadend: (evt: ProgressEvent) => void;\n  onabort: (evt: ProgressEvent) => void;\n\n  abort(): void;\n\n  readAsText(fe: IFile, encoding?: string): void;\n\n  readAsDataURL(fe: IFile): void;\n\n  readAsBinaryString(fe: IFile): void;\n\n  readAsArrayBuffer(fe: IFile): void;\n\n  /**\n   * @hidden\n   */\n  [key: string]: any;\n}\n\ninterface Window extends LocalFileSystem {}\n\ndeclare const window: Window;\n\n/**\n * @name File\n * @premier filesystem\n * @description\n * This plugin implements a File API allowing read/write access to files residing on the device.\n *\n * The File class implements static convenience functions to access files and directories.\n *\n * Example:\n * ```\n * import { File } from '@ionic-native/file/ngx';\n *\n * constructor(private file: File) { }\n *\n * ...\n *\n * this.file.checkDir(this.file.dataDirectory, 'mydir').then(_ => console.log('Directory exists')).catch(err =>\n *   console.log('Directory doesn't exist'));\n *\n * ```\n *\n *  This plugin is based on several specs, including : The HTML5 File API http: //www.w3.org/TR/FileAPI/\n *  The (now-defunct) Directories and System extensions Latest: http: //www.w3.org/TR/2012/WD-file-system-api-20120417/\n *  Although most of the plugin code was written when an earlier spec was current: http:\n *   //www.w3.org/TR/2011/WD-file-system-api-20110419/ It also implements the FileWriter spec : http:\n *   //dev.w3.org/2009/dap/file-system/file-writer.html\n *  @interfaces\n *  IFile\n *  Entry\n *  DirectoryEntry\n *  DirectoryReader\n *  FileSystem\n */\n@Plugin({\n  pluginName: 'File',\n  plugin: 'cordova-plugin-file',\n  pluginRef: 'cordova.file',\n  repo: 'https://github.com/apache/cordova-plugin-file',\n  platforms: ['Android', 'Browser', 'iOS', 'macOS', 'Windows'],\n})\n@Injectable()\nexport class File extends IonicNativePlugin {\n  /**\n   *  Read-only directory where the application is installed.\n   */\n  @CordovaProperty() applicationDirectory: string;\n\n  /**\n   *  Read-only directory where the application is installed.\n   */\n  @CordovaProperty() applicationStorageDirectory: string;\n\n  /**\n   * Where to put app-specific data files.\n   */\n  @CordovaProperty() dataDirectory: string;\n\n  /**\n   * Cached files that should survive app restarts.\n   * Apps should not rely on the OS to delete files in here.\n   */\n  @CordovaProperty() cacheDirectory: string;\n\n  /**\n   * Android: the application space on external storage.\n   */\n  @CordovaProperty() externalApplicationStorageDirectory: string;\n\n  /**\n   *  Android: Where to put app-specific data files on external storage.\n   */\n  @CordovaProperty() externalDataDirectory: string;\n\n  /**\n   * Android: the application cache on external storage.\n   */\n  @CordovaProperty() externalCacheDirectory: string;\n\n  /**\n   * Android: the external storage (SD card) root.\n   */\n  @CordovaProperty() externalRootDirectory: string;\n\n  /**\n   * iOS: Temp directory that the OS can clear at will.\n   */\n  @CordovaProperty() tempDirectory: string;\n\n  /**\n   * iOS: Holds app-specific files that should be synced (e.g. to iCloud).\n   */\n  @CordovaProperty() syncedDataDirectory: string;\n\n  /**\n   * iOS: Files private to the app, but that are meaningful to other applications (e.g. Office files)\n   */\n  @CordovaProperty() documentsDirectory: string;\n\n  /**\n   * BlackBerry10: Files globally available to all apps\n   */\n  @CordovaProperty() sharedDirectory: string;\n\n  cordovaFileError: any = {\n    1: 'NOT_FOUND_ERR',\n    2: 'SECURITY_ERR',\n    3: 'ABORT_ERR',\n    4: 'NOT_READABLE_ERR',\n    5: 'ENCODING_ERR',\n    6: 'NO_MODIFICATION_ALLOWED_ERR',\n    7: 'INVALID_STATE_ERR',\n    8: 'SYNTAX_ERR',\n    9: 'INVALID_MODIFICATION_ERR',\n    10: 'QUOTA_EXCEEDED_ERR',\n    11: 'TYPE_MISMATCH_ERR',\n    12: 'PATH_EXISTS_ERR',\n    13: 'WRONG_ENTRY_TYPE',\n    14: 'DIR_READ_ERR',\n  };\n\n  /**\n   * Get free disk space in Bytes\n   * @returns {Promise<number>} Returns a promise that resolves with the remaining free disk space in Bytes\n   */\n  @CordovaCheck()\n  getFreeDiskSpace(): Promise<number> {\n    return getPromise<any>((resolve, reject) => {\n      cordova.exec(resolve as (data: any) => any, reject as (data: any) => any, 'File', 'getFreeDiskSpace', []);\n    });\n  }\n\n  /**\n   * Check if a directory exists in a certain path, directory.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} dir Name of directory to check\n   * @returns {Promise<boolean>} Returns a Promise that resolves to true if the directory exists or rejects with an\n   *   error.\n   */\n  @CordovaCheck()\n  checkDir(path: string, dir: string): Promise<boolean> {\n    if (/^\\//.test(dir)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    const fullPath = path + dir;\n    return this.resolveDirectoryUrl(fullPath).then(() => {\n      return true;\n    });\n  }\n\n  /**\n   * Creates a new directory in the specific path.\n   * The replace boolean value determines whether to replace an existing directory with the same name.\n   * If an existing directory exists and the replace value is false, the promise will fail and return an error.\n   *\n   * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} dirName Name of directory to create\n   * @param {boolean} replace If true, replaces file with same name. If false returns error\n   * @returns {Promise<DirectoryEntry>} Returns a Promise that resolves with a DirectoryEntry or rejects with an error.\n   */\n  @CordovaCheck()\n  createDir(path: string, dirName: string, replace: boolean): Promise<DirectoryEntry> {\n    if (/^\\//.test(dirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    const options: Flags = {\n      create: true,\n    };\n\n    if (!replace) {\n      options.exclusive = true;\n    }\n\n    return this.resolveDirectoryUrl(path).then(fse => {\n      return this.getDirectory(fse, dirName, options);\n    });\n  }\n\n  /**\n   * Remove a directory at a given path.\n   *\n   * @param {string} path The path to the directory\n   * @param {string} dirName The directory name\n   * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.\n   */\n  @CordovaCheck()\n  removeDir(path: string, dirName: string): Promise<RemoveResult> {\n    if (/^\\//.test(dirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getDirectory(fse, dirName, { create: false });\n      })\n      .then(de => {\n        return this.remove(de);\n      });\n  }\n\n  /**\n   * Move a directory to a given path.\n   *\n   * @param {string} path The source path to the directory\n   * @param {string} dirName The source directory name\n   * @param {string} newPath The destination path to the directory\n   * @param {string} newDirName The destination directory name\n   * @returns {Promise<DirectoryEntry|Entry>} Returns a Promise that resolves to the new DirectoryEntry object or\n   *   rejects with an error.\n   */\n  @CordovaCheck()\n  moveDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<DirectoryEntry | Entry> {\n    newDirName = newDirName || dirName;\n\n    if (/^\\//.test(newDirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getDirectory(fse, dirName, { create: false });\n      })\n      .then(srcde => {\n        return this.resolveDirectoryUrl(newPath).then(destenation => {\n          return this.move(srcde, destenation, newDirName);\n        });\n      });\n  }\n\n  /**\n   * Copy a directory in various methods. If destination directory exists, will fail to copy.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param {string} dirName Name of directory to copy\n   * @param {string} newPath Base FileSystem of new location\n   * @param {string} newDirName New name of directory to copy to (leave blank to remain the same)\n   * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.\n   */\n  @CordovaCheck()\n  copyDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<Entry> {\n    if (/^\\//.test(newDirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getDirectory(fse, dirName, { create: false });\n      })\n      .then(srcde => {\n        return this.resolveDirectoryUrl(newPath).then(deste => {\n          return this.copy(srcde, deste, newDirName);\n        });\n      });\n  }\n\n  /**\n   * List files and directory from a given path.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param {string} dirName Name of directory\n   * @returns {Promise<Entry[]>} Returns a Promise that resolves to an array of Entry objects or rejects with an error.\n   */\n  @CordovaCheck()\n  listDir(path: string, dirName: string): Promise<Entry[]> {\n    if (/^\\//.test(dirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<Entry[]>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getDirectory(fse, dirName, {\n          create: false,\n          exclusive: false,\n        });\n      })\n      .then(de => {\n        const reader = de.createReader();\n        return this.readEntries(reader);\n      });\n  }\n\n  /**\n   * Removes all files and the directory from a desired location.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} dirName Name of directory\n   * @returns {Promise<RemoveResult>} Returns a Promise that resolves with a RemoveResult or rejects with an error.\n   */\n  @CordovaCheck()\n  removeRecursively(path: string, dirName: string): Promise<RemoveResult> {\n    if (/^\\//.test(dirName)) {\n      const err = new FileError(5);\n      err.message = 'directory cannot start with /';\n      return Promise.reject<RemoveResult>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getDirectory(fse, dirName, { create: false });\n      })\n      .then(de => {\n        return this.rimraf(de);\n      });\n  }\n\n  /**\n   * Check if a file exists in a certain path, directory.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} file Name of file to check\n   * @returns {Promise<boolean>} Returns a Promise that resolves with a boolean or rejects with an error.\n   */\n  @CordovaCheck()\n  checkFile(path: string, file: string): Promise<boolean> {\n    if (/^\\//.test(file)) {\n      const err = new FileError(5);\n      err.message = 'file cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveLocalFilesystemUrl(path + file).then(fse => {\n      if (fse.isFile) {\n        return true;\n      } else {\n        const err = new FileError(13);\n        err.message = 'input is not a file';\n        return Promise.reject<boolean>(err);\n      }\n    });\n  }\n\n  /**\n   * Creates a new file in the specific path.\n   * The replace boolean value determines whether to replace an existing file with the same name.\n   * If an existing file exists and the replace value is false, the promise will fail and return an error.\n   *\n   * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName Name of file to create\n   * @param {boolean} replace If true, replaces file with same name. If false returns error\n   * @returns {Promise<FileEntry>} Returns a Promise that resolves to a FileEntry or rejects with an error.\n   */\n  @CordovaCheck()\n  createFile(path: string, fileName: string, replace: boolean): Promise<FileEntry> {\n    if (/^\\//.test(fileName)) {\n      const err = new FileError(5);\n      err.message = 'file-name cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    const options: Flags = {\n      create: true,\n    };\n\n    if (!replace) {\n      options.exclusive = true;\n    }\n\n    return this.resolveDirectoryUrl(path).then(fse => {\n      return this.getFile(fse, fileName, options);\n    });\n  }\n\n  /**\n   * Removes a file from a desired location.\n   *\n   * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName Name of file to remove\n   * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.\n   */\n  @CordovaCheck()\n  removeFile(path: string, fileName: string): Promise<RemoveResult> {\n    if (/^\\//.test(fileName)) {\n      const err = new FileError(5);\n      err.message = 'file-name cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getFile(fse, fileName, { create: false });\n      })\n      .then(fe => {\n        return this.remove(fe);\n      });\n  }\n\n  /**\n   * Write a new file to the desired location.\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName path relative to base path\n   * @param {string | Blob | ArrayBuffer} text content, blob or ArrayBuffer to write\n   * @param {IWriteOptions} whether to replace/append to an existing file. See IWriteOptions for more information.\n   * @returns {Promise<any>} Returns a Promise that resolves to updated file entry or rejects with an error.\n   */\n  @CordovaCheck()\n  writeFile(\n    path: string,\n    fileName: string,\n    text: string | Blob | ArrayBuffer,\n    options: IWriteOptions = {}\n  ): Promise<any> {\n    if (/^\\//.test(fileName)) {\n      const err = new FileError(5);\n      err.message = 'file-name cannot start with /';\n      return Promise.reject(err);\n    }\n\n    const getFileOpts: Flags = {\n      create: !options.append,\n      exclusive: !options.replace,\n    };\n\n    return this.resolveDirectoryUrl(path)\n      .then((directoryEntry: DirectoryEntry) => {\n        return this.getFile(directoryEntry, fileName, getFileOpts);\n      })\n      .then((fileEntry: FileEntry) => {\n        return this.writeFileEntry(fileEntry, text, options);\n      });\n  }\n\n  /**\n   * Write content to FileEntry.\n   * @hidden\n   * Write to an existing file.\n   * @param {FileEntry} fe file entry object\n   * @param {string | Blob | ArrayBuffer} text text content or blob to write\n   * @param {IWriteOptions} options replace file if set to true. See WriteOptions for more information.\n   * @returns {Promise<FileEntry>}  Returns a Promise that resolves to updated file entry or rejects with an error.\n   */\n  private writeFileEntry(fe: FileEntry, text: string | Blob | ArrayBuffer, options: IWriteOptions) {\n    return this.createWriter(fe)\n      .then(writer => {\n        if (options.append) {\n          writer.seek(writer.length);\n        }\n\n        if (options.truncate) {\n          writer.truncate(options.truncate);\n        }\n\n        return this.write(writer, text);\n      })\n      .then(() => fe);\n  }\n\n  /**\n   * Write to an existing file.\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName path relative to base path\n   * @param {string | Blob} text content or blob to write\n   * @returns {Promise<void>} Returns a Promise that resolves or rejects with an error.\n   */\n  @CordovaCheck()\n  writeExistingFile(path: string, fileName: string, text: string | Blob): Promise<void> {\n    return this.writeFile(path, fileName, text, { replace: true });\n  }\n\n  /**\n   * Read the contents of a file as text.\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} file Name of file, relative to path.\n   * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string or rejects with\n   *   an error.\n   */\n  @CordovaCheck()\n  readAsText(path: string, file: string): Promise<string> {\n    return this.readFile<string>(path, file, 'Text');\n  }\n\n  /**\n   * Read file and return data as a base64 encoded data url.\n   * A data url is of the form:\n   *      data: [<mediatype>][;base64],<data>\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} file Name of file, relative to path.\n   * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as data URL or rejects\n   *   with an error.\n   */\n  @CordovaCheck()\n  readAsDataURL(path: string, file: string): Promise<string> {\n    return this.readFile<string>(path, file, 'DataURL');\n  }\n\n  /**\n   * Read file and return data as a binary data.\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} file Name of file, relative to path.\n   * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string rejects with an\n   *   error.\n   */\n  @CordovaCheck()\n  readAsBinaryString(path: string, file: string): Promise<string> {\n    return this.readFile<string>(path, file, 'BinaryString');\n  }\n\n  /**\n   * Read file and return data as an ArrayBuffer.\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} file Name of file, relative to path.\n   * @returns {Promise<ArrayBuffer>} Returns a Promise that resolves with the contents of the file as ArrayBuffer or\n   *   rejects with an error.\n   */\n  @CordovaCheck()\n  readAsArrayBuffer(path: string, file: string): Promise<ArrayBuffer> {\n    return this.readFile<ArrayBuffer>(path, file, 'ArrayBuffer');\n  }\n\n  /**\n   * Move a file to a given path.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName Name of file to move\n   * @param {string} newPath Base FileSystem of new location\n   * @param {string} newFileName New name of file to move to (leave blank to remain the same)\n   * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry or rejects with an error.\n   */\n  @CordovaCheck()\n  moveFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry> {\n    newFileName = newFileName || fileName;\n\n    if (/^\\//.test(newFileName)) {\n      const err = new FileError(5);\n      err.message = 'file name cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getFile(fse, fileName, { create: false });\n      })\n      .then(srcfe => {\n        return this.resolveDirectoryUrl(newPath).then(deste => {\n          return this.move(srcfe, deste, newFileName);\n        });\n      });\n  }\n\n  /**\n   * Copy a file in various methods. If file exists, will fail to copy.\n   *\n   * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n   * @param {string} fileName Name of file to copy\n   * @param {string} newPath Base FileSystem of new location\n   * @param {string} newFileName New name of file to copy to (leave blank to remain the same)\n   * @returns {Promise<Entry>} Returns a Promise that resolves to an Entry or rejects with an error.\n   */\n  @CordovaCheck()\n  copyFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry> {\n    newFileName = newFileName || fileName;\n\n    if (/^\\//.test(newFileName)) {\n      const err = new FileError(5);\n      err.message = 'file name cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then(fse => {\n        return this.getFile(fse, fileName, { create: false });\n      })\n      .then(srcfe => {\n        return this.resolveDirectoryUrl(newPath).then(deste => {\n          return this.copy(srcfe, deste, newFileName);\n        });\n      });\n  }\n\n  /**\n   * @hidden\n   */\n  private fillErrorMessage(err: FileError): void {\n    try {\n      err.message = this.cordovaFileError[err.code];\n    } catch (e) {}\n  }\n\n  /**\n   * Resolves a local file system URL\n   * @param fileUrl {string} file system url\n   * @returns {Promise<Entry>}\n   */\n  @CordovaCheck()\n  resolveLocalFilesystemUrl(fileUrl: string): Promise<Entry> {\n    return getPromise<Entry>((resolve, reject) => {\n      try {\n        window.resolveLocalFileSystemURL(\n          fileUrl,\n          (entry: Entry) => {\n            resolve(entry);\n          },\n          err => {\n            this.fillErrorMessage(err);\n            reject(err);\n          }\n        );\n      } catch (xc) {\n        this.fillErrorMessage(xc);\n        reject(xc);\n      }\n    });\n  }\n\n  /**\n   * Resolves a local directory url\n   * @param directoryUrl {string} directory system url\n   * @returns {Promise<DirectoryEntry>}\n   */\n  @CordovaCheck()\n  resolveDirectoryUrl(directoryUrl: string): Promise<DirectoryEntry> {\n    return this.resolveLocalFilesystemUrl(directoryUrl).then(de => {\n      if (de.isDirectory) {\n        return de as DirectoryEntry;\n      } else {\n        const err = new FileError(13);\n        err.message = 'input is not a directory';\n        return Promise.reject<DirectoryEntry>(err);\n      }\n    });\n  }\n\n  /**\n   * Get a directory\n   * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method\n   * @param directoryName {string} Directory name\n   * @param flags {Flags} Options\n   * @returns {Promise<DirectoryEntry>}\n   */\n  @CordovaCheck()\n  getDirectory(directoryEntry: DirectoryEntry, directoryName: string, flags: Flags): Promise<DirectoryEntry> {\n    return new Promise<DirectoryEntry>((resolve, reject) => {\n      try {\n        directoryEntry.getDirectory(\n          directoryName,\n          flags,\n          de => {\n            resolve(de);\n          },\n          err => {\n            this.fillErrorMessage(err);\n            reject(err);\n          }\n        );\n      } catch (xc) {\n        this.fillErrorMessage(xc);\n        reject(xc);\n      }\n    });\n  }\n\n  /**\n   * Get a file\n   * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method\n   * @param fileName {string} File name\n   * @param flags {Flags} Options\n   * @returns {Promise<FileEntry>}\n   */\n  @CordovaCheck()\n  getFile(directoryEntry: DirectoryEntry, fileName: string, flags: Flags): Promise<FileEntry> {\n    return new Promise<FileEntry>((resolve, reject) => {\n      try {\n        directoryEntry.getFile(fileName, flags, resolve, err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        });\n      } catch (xc) {\n        this.fillErrorMessage(xc);\n        reject(xc);\n      }\n    });\n  }\n\n  private readFile<T>(\n    path: string,\n    file: string,\n    readAs: 'ArrayBuffer' | 'BinaryString' | 'DataURL' | 'Text'\n  ): Promise<T> {\n    if (/^\\//.test(file)) {\n      const err = new FileError(5);\n      err.message = 'file-name cannot start with /';\n      return Promise.reject<any>(err);\n    }\n\n    return this.resolveDirectoryUrl(path)\n      .then((directoryEntry: DirectoryEntry) => {\n        return this.getFile(directoryEntry, file, { create: false });\n      })\n      .then((fileEntry: FileEntry) => {\n        const reader = new FileReader();\n        return getPromise<T>((resolve, reject) => {\n          reader.onloadend = () => {\n            if (reader.result !== undefined || reader.result !== null) {\n              resolve((reader.result as any) as T);\n            } else if (reader.error !== undefined || reader.error !== null) {\n              reject(reader.error);\n            } else {\n              reject({ code: null, message: 'READER_ONLOADEND_ERR' });\n            }\n          };\n\n          fileEntry.file(\n            file => {\n              reader[`readAs${readAs}`].call(reader, file);\n            },\n            error => {\n              reject(error);\n            }\n          );\n        });\n      });\n  }\n\n  /**\n   * @hidden\n   */\n  private remove(fe: Entry): Promise<RemoveResult> {\n    return new Promise<RemoveResult>((resolve, reject) => {\n      fe.remove(\n        () => {\n          resolve({ success: true, fileRemoved: fe });\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private move(srce: Entry, destdir: DirectoryEntry, newName: string): Promise<Entry> {\n    return new Promise<Entry>((resolve, reject) => {\n      srce.moveTo(\n        destdir,\n        newName,\n        deste => {\n          resolve(deste);\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private copy(srce: Entry, destdir: DirectoryEntry, newName: string): Promise<Entry> {\n    return new Promise<Entry>((resolve, reject) => {\n      srce.copyTo(\n        destdir,\n        newName,\n        deste => {\n          resolve(deste);\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private readEntries(dr: DirectoryReader): Promise<Entry[]> {\n    return new Promise<Entry[]>((resolve, reject) => {\n      dr.readEntries(\n        entries => {\n          resolve(entries);\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private rimraf(de: DirectoryEntry): Promise<RemoveResult> {\n    return new Promise<RemoveResult>((resolve, reject) => {\n      de.removeRecursively(\n        () => {\n          resolve({ success: true, fileRemoved: de });\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private createWriter(fe: FileEntry): Promise<FileWriter> {\n    return new Promise<FileWriter>((resolve, reject) => {\n      fe.createWriter(\n        writer => {\n          resolve(writer);\n        },\n        err => {\n          this.fillErrorMessage(err);\n          reject(err);\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private write(writer: FileWriter, gu: string | Blob | ArrayBuffer): Promise<any> {\n    if (gu instanceof Blob) {\n      return this.writeFileInChunks(writer, gu);\n    }\n\n    return new Promise<any>((resolve, reject) => {\n      writer.onwriteend = evt => {\n        if (writer.error) {\n          reject(writer.error);\n        } else {\n          resolve(evt);\n        }\n      };\n      writer.write(gu);\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  private writeFileInChunks(writer: FileWriter, file: Blob) {\n    const BLOCK_SIZE = 1024 * 1024;\n    let writtenSize = 0;\n\n    function writeNextChunk() {\n      const size = Math.min(BLOCK_SIZE, file.size - writtenSize);\n      const chunk = file.slice(writtenSize, writtenSize + size);\n\n      writtenSize += size;\n      writer.write(chunk);\n    }\n\n    return getPromise<any>((resolve, reject) => {\n      writer.onerror = reject as (event: ProgressEvent) => void;\n      writer.onwrite = () => {\n        if (writtenSize < file.size) {\n          writeNextChunk();\n        } else {\n          resolve();\n        }\n      };\n      writeNextChunk();\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}